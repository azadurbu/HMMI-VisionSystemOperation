using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using VisionSystemOperation.Device;

namespace VisionSystemOperation
{
    public enum eLogType
    {
        INSPECTION,
        CAMERA,
        LIGHT,
        DIO,
        SEQ,
        INFORMATION,
        ERROR,
        RESULT,
        ALL
    }

    public class Logger
    {
        public static string logDir = "";
        public static string resultDir = "";
        public static string iamgeDir = "";

        private static object _objLock = new object();

        public void Initialize(string filePath = "")
        {
            if (filePath == "")
                logDir = Path.Combine(Directory.GetCurrentDirectory(), "log");
            else
                logDir = filePath;

            if (!Directory.Exists(logDir))
                Directory.CreateDirectory(logDir);
        }

        private void WriteFirstLine(eLogType logType)
        {


        }

        public void WriteAsync(eLogType logType, string logMessage)
        {

            System.Reflection.Assembly asm = System.Reflection.Assembly.GetExecutingAssembly();
            string msg = "===================Program Version " + asm.GetName().Version.ToString() + " ===================";

            string logpath = getLogPath(logType);
            string strDir = logpath.Substring(0, logpath.LastIndexOf('\\'));
            string time = GetTimeString();
            string message = "[" + time + "] " + logMessage;
            message = message.Replace("\r\n", "");

            if (!Directory.Exists(strDir))
                Directory.CreateDirectory(strDir);

            lock (_objLock)
            {
                try
                {
                    StreamWriter log = new StreamWriter(logpath, true);
                    {
                        using (log)
                        {
                            try { log.WriteLineAsync(message); } catch { }
                        }
                    }
                }
                catch (Exception)
                {
                }
            }

            //FormMain.Instance().ctrlLog.AddLog(message);
        }

        public string[] ResultGetData(eLogType logType)
        {
            string logpath = getLogPath(logType);
            if (File.Exists(logpath))
            {
                string[] value = File.ReadAllLines(logpath);

                return value;
            }
            else
                return null;
        }

        public void ResultUpdate(eLogType logType, int total, int pallet, int NGcount)
        {
            string logpath = getLogPath(logType);
            string strDir = logpath.Substring(0, logpath.LastIndexOf('\\'));
            string time = GetTimeString();
            //string message = "[" + time + "] " + logMessage;
            //message = message.Replace("\r\n", "");

            if (!Directory.Exists(strDir))
                Directory.CreateDirectory(strDir);

            lock (_objLock)
            {
                StreamWriter log = new StreamWriter(logpath, false);
                using (log)
                {
                    log.WriteLine(total.ToString());
                    log.WriteLine(pallet.ToString());
                    log.WriteLine(NGcount.ToString());
                }
            }
        }

        private string getLogPath(eLogType logType)
        {
            string logPath = string.Format(@"{0}\{1:00}\{2:00}{3:00}\log_{4:0000}{5:00}{6:00}_" + logType.ToString() + ".log", logDir, DateTime.Now.Year, DateTime.Now.Month, DateTime.Now.Day, DateTime.Now.Year, DateTime.Now.Month, DateTime.Now.Day);
            return logPath;
        }

        public void WriteException(eLogType logType, Exception exception)
        {
            string logpath = getLogPath(logType);
            string strDir = logpath.Substring(0, logpath.LastIndexOf('\\'));
            string time = GetTimeString();
            string logMessage = "[" + time + "] " + exception.StackTrace + " : " + exception.Message;
            logMessage = logMessage.Replace("\r\n", "");

            if (!Directory.Exists(strDir))
                Directory.CreateDirectory(strDir);

            lock (_objLock)
            {
                StreamWriter log = new StreamWriter(logpath, true);
                using (log)
                {
                    log.WriteLine(logMessage);
                }
            }
        }
        public static void DeleteFilesInDir(string dir, string searchPattern, int day)
        {
            DirectoryInfo di = new DirectoryInfo(dir);    // 인자값으로 들어온 절대 주소를 객체로 정의합니다.
            Dirs(di, searchPattern, day);                 // 삭제를 시작합니다.
        }

        private static void Dirs(DirectoryInfo dirinfo, string searchPattern, int day)
        {
            DirectoryInfo[] di = dirinfo.GetDirectories(); // 받은 주소의 하위 폴더 주소들을 반환합니다.

            if (di.Length < 1) // 반환받은 주소가 없을 경우 빠져나갑니다.
            {
                return;
            }

            for (int i = 0; i < di.Length; i++) // 반환받은 주소의 수 만큼 반복문을 실행시킵니다.
            {
                if (di[i].GetFiles().Count<FileInfo>() < 1 && di[i].GetDirectories().Count<DirectoryInfo>() < 1) // 하위 폴더가 빈 폴더면 삭제
                {
                    di[i].Delete();
                }
                else
                {
                    DelFiles(di[i], searchPattern, day); // 하위 폴더의 파일을 지움
                    Dirs(di[i], searchPattern, day); //  하위 폴더로 재귀호출
                }
            }
        }


        private static void DelFiles(DirectoryInfo diinfo, string searchPattern, int day)
        {
            try
            {
                DateTime dayAgoTime = DateTime.Now.AddSeconds(-(day * 3600 * 24)); // 인자로 받은 날을 객체로 정의합니다.
                DateTime agoTime = DateTime.Now.AddSeconds(-(1 * 3600 * 24)); // bmp 삭제를 위해
                foreach (FileInfo fileName in diinfo.GetFiles()) // 해당 폴더에 파일 갯수 만큼 반복합니다.
                {
                    if (searchPattern.Equals(".*")) //확장명이 .*일 경우 모든 파일을 제거합니다.
                    {
                        DateTime dt = fileName.CreationTime; // 파일을 만들었던 시간을 객체로 정의합니다.

                        if (dayAgoTime > dt) // 사용자가 설정한 날보다 더 이전에 만들었을 경우
                        {
                            fileName.Delete(); // 파일을 제거합니다.
                        }
                    }
                    else if (fileName.Extension.Equals(searchPattern)) // 인자값의 확장명이 반복문의 확장명과 같을 경우 제거합니다.
                    {
                        DateTime dt = fileName.CreationTime; // 파일을 만들었던 시간을 객체로 정의합니다.
                        if (dayAgoTime > dt) // 사용자가 설정한 날보다 더 이전에 만들었을 경우
                        {
                            fileName.Delete(); // 파일을 제거합니다.
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Machine.logger.WriteException(eLogType.ERROR, ex);
            }
        }

        public string GetTimeString()
        {
            // 시간은 plc의 시간. ms는 없으므로 pc의 ms
            DateTime now = DateTime.Now;
            string strTime = string.Format(@"{0:00}{1:00} {2:00}:{3:00}:{4:00}.{5:000}ms", now.Month, now.Day,
                now.Hour, now.Minute, now.Second, now.Millisecond);
            return strTime;
        }
        public List<LoggerUI> LoadLogs(List<eLogType> eLog, DateTime? fromDateTime = null, DateTime? toDateTime = null)
        {
            List<eLogType> logTypes = eLog;

            if (logTypes.Contains(eLogType.ALL))
            {
                logTypes = new List<eLogType>((eLogType[])Enum.GetValues(typeof(eLogType)));
            }

            List<LoggerUI> logs = new List<LoggerUI>();
            DateTime startDate = fromDateTime ?? Machine.startDate;
            DateTime todayDate = toDateTime ?? DateTime.Today;

            for (DateTime date = startDate; date <= todayDate; date = date.AddDays(1))
            { 
                foreach (eLogType logType in logTypes)
                {

                    string filePath = string.Format(@"{0}\{1:00}\{2:00}{3:00}\log_{4:0000}{5:00}{6:00}_" + logType.ToString() + ".log", logDir, date.Year, date.Month, date.Day, date.Year, date.Month, date.Day);

                    try
                    {
                        if (File.Exists(filePath))  // Check if the file exists
                        {
                            var lines = File.ReadAllLines(filePath);

                            var regex = new Regex(@"\[(?<dateTime>\d{4}\s+\d{2}:\d{2}:\d{2}\.\d{3}ms)\]\s+(?<errorType>.*?)\:\s+(?<message>.*)");

                            foreach (var line in lines)
                            {
                                var match = regex.Match(line);

                                if (match.Success)
                                {
                                    string dateTimeString = date.Year+match.Groups["dateTime"].Value;
                                    dateTimeString = dateTimeString.Replace("ms", "");
                                    DateTime logDateTime;

                                    if (DateTime.TryParseExact(dateTimeString, "yyyyMMdd HH:mm:ss.fff", CultureInfo.InvariantCulture, DateTimeStyles.None, out logDateTime))
                                    {
                                        string errorType = match.Groups["errorType"].Value;

                                        string message = match.Groups["message"].Value;

                                        LoggerUI logEntry = new LoggerUI
                                        {
                                            LogTime = logDateTime, 
                                            LogType = logType.ToString(),
                                            Classification = errorType, 
                                            Information = message,
                                        };
                                        logs.Add(logEntry);
                                    }
                                }
                            }
                            // Order the logs by datetime
                            logs = logs.OrderBy(log => log.LogTime).ToList();
                        }
                    }
                    catch (Exception)
                    {
                    }
                }
            }
            return logs;
        }
    }
    
    public class LoggerUI
    {
        public DateTime LogTime { get; set; }
        public string LogType { get; set; }
        public string Classification { get; set; }
        public string Information { get; set; }
    }
}
